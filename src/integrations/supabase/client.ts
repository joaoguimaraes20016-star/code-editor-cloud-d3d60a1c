// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;
const EXPECTED_PROJECT_REF = 'kqfyevdblvgxaycdvfxe';
type SupabaseKeyType = 'publishable' | 'jwt' | 'unknown' | 'missing';

function detectSupabaseKeyType(token: string | undefined | null): SupabaseKeyType {
  if (!token) return 'missing';
  if (token.startsWith('sb_publishable_')) return 'publishable';
  if (token.split('.').length === 3) return 'jwt';
  return 'unknown';
}

function decodeAnonKeyRefAndRole(token: string | undefined | null): { tokenRef: string | null; tokenRole: string | null; keyType: SupabaseKeyType } {
  const keyType = detectSupabaseKeyType(token);
  if (!token || keyType !== 'jwt') return { tokenRef: null, tokenRole: null, keyType };

  const parts = token.split('.');
  if (parts.length < 2) return { tokenRef: null, tokenRole: null, keyType };

  try {
    const base64 = parts[1].replace(/-/g, '+').replace(/_/g, '/');
    const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, '=');

    // atob is available in the browser; Buffer fallback for non-browser dev environments
    let json: string;
    if (typeof atob === 'function') {
      json = atob(padded);
    } else if (typeof Buffer !== 'undefined') {
      json = Buffer.from(padded, 'base64').toString('utf-8');
    } else {
      return { tokenRef: null, tokenRole: null, keyType };
    }

    const payload = JSON.parse(json) as { ref?: string; role?: string; user_role?: string };
    const tokenRef = payload.ref ?? null;
    const tokenRole = payload.role ?? payload.user_role ?? null;

    return { tokenRef, tokenRole, keyType };
  } catch {
    return { tokenRef: null, tokenRole: null, keyType };
  }
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  }
});

// DEV-only startup health check: log project ref and list non-system schemas/tables
if (import.meta.env.DEV) {
  (async () => {
    try {
      const rawUrl = SUPABASE_URL || (import.meta.env.NEXT_PUBLIC_SUPABASE_URL as string) || '';
      let projectRef = 'unset';
      let urlHostRef: string | null = null;
      let host: string | null = null;
      try {
        if (rawUrl) {
          const u = new URL(rawUrl);
          host = u.hostname;
          projectRef = host.split('.')[0] || projectRef;
          if (host.endsWith('.supabase.co')) {
            urlHostRef = host.split('.')[0] || null;
          }
        }
      } catch (e) {
        projectRef = rawUrl;
      }

      const { tokenRef, tokenRole, keyType } = decodeAnonKeyRefAndRole(SUPABASE_ANON_KEY);

      if (!SUPABASE_URL) {
        console.error('[Supabase][dev] VITE_SUPABASE_URL is not set.');
      }

      if (!SUPABASE_ANON_KEY) {
        console.error('[Supabase][dev] VITE_SUPABASE_ANON_KEY is not set.');
      }

      if (host && !host.endsWith('.supabase.co')) {
        console.warn('[Supabase][dev] VITE_SUPABASE_URL host does not end with .supabase.co:', host);
      }

      console.debug('[Supabase][dev] SUPABASE_URL=', rawUrl);
      console.debug('[Supabase][dev] projectRef(from URL)=', projectRef);
      console.debug('[Supabase][dev] anon key type=', keyType);
      console.debug('[Supabase][dev] anon token ref=', tokenRef);
      console.debug('[Supabase][dev] anon token role=', tokenRole);

      if (keyType === 'jwt' && urlHostRef && tokenRef && urlHostRef !== tokenRef) {
        console.error('[Supabase][dev] Anon key project ref does not match VITE_SUPABASE_URL project ref.', {
          urlProjectRef: urlHostRef,
          tokenProjectRef: tokenRef,
        });
        throw new Error(
          '[Supabase][dev] Misconfigured Supabase anon key: token project ref does not match VITE_SUPABASE_URL. Update VITE_SUPABASE_ANON_KEY in .env.local to use the anon key from the correct project.'
        );
      }

      if (keyType === 'jwt' && tokenRef && tokenRef !== EXPECTED_PROJECT_REF) {
        console.warn('[Supabase][dev] Anon key ref does not match expected project ref.', {
          expectedRef: EXPECTED_PROJECT_REF,
          tokenRef,
        });
      }

      // Query information_schema.tables to detect available schemas/tables (may be restricted by PostgREST permissions)
      try {
        const { data, error } = await supabase
          .from('information_schema.tables')
          .select('table_schema,table_name')
          .neq('table_schema', 'pg_catalog')
          .neq('table_schema', 'information_schema')
          .order('table_schema', { ascending: true })
          .limit(50);

        if (error) {
          console.debug('[Supabase][dev] information_schema query error:', error);
        } else {
          console.debug('[Supabase][dev] discovered tables count=', Array.isArray(data) ? data.length : 0);
          console.debug('[Supabase][dev] sample tables=', (data || []).slice(0, 20));

          const crmTables = ['appointments', 'payments', 'team_pipeline_stages', 'confirmation_tasks'];
          const found = (data || []).some((r: any) => crmTables.includes(r.table_name));
          if (!found) {
            console.warn('[Supabase][dev] Connected DB has no CRM tables; check Supabase project ref or run migrations.');
          }
        }
      } catch (err) {
        console.debug('[Supabase][dev] information_schema query failed:', err);
      }
    } catch (err) {
      console.debug('[Supabase][dev] startup health check failed:', err);
    }
  })();
}